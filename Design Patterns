Design Patterns:

1.Creational Design Pattern
		Factory Pattern
		Abstract Factory Pattern
		Singleton Pattern
		Prototype Pattern
		Builder Pattern.
2. Structural Design Pattern
		Adapter Pattern
		Bridge Pattern
		Composite Pattern
		Decorator Pattern
		Facade Pattern
		Flyweight Pattern
		Proxy Pattern
3. Behavioral Design Pattern
		Chain Of Responsibility Pattern
		Command Pattern
		Interpreter Pattern
		Iterator Pattern
		Mediator Pattern
		Memento Pattern
		Observer Pattern
		State Pattern
		Strategy Pattern
		Template Pattern
		Visitor Pattern



1. Builder Pattern:

remove the public constructor from the BankAccount class and replace it with a private constructor so that accounts can only be created via the builder. 

create a complex object and its complex parts.

there are two specific problems that we need to solve:

Too many constructor arguments.
Incorrect object state.

With the Factory pattern, you produce instances of implementations (Apple, Banana, Cherry, etc.) of a particular interface -- say, IFruit.

With the Abstract Factory pattern, you provide a way for anyone to provide their own factory. This allows your warehouse to be either an IFruitFactory or an IJuiceFactory, without requiring your warehouse to know anything about fruits or juices.
Abstract Factory: Provides an interface for creating families of related or dependent objects without specifying their concrete classes.


Prototype design pattern is used in scenarios where application needs to create a number of instances of a class, which has almost same state or differs very little.

Singleton Pattern
https://javarevisited.blogspot.com/2011/03/10-interview-questions-on-singleton.html
https://javarevisited.blogspot.com/2012/07/why-enum-singleton-are-better-in-java.html
https://www.geeksforgeeks.org/java-singleton-design-pattern-practices-examples/#:~:text=Thread%20Safe%20Singleton%3A%20A%20thread,can't%20access%20it%20simultaneously.&text=Pros%3A,-Lazy%20initialization%20is&text=It%20is%20also%20thread%20safe.
https://www.geeksforgeeks.org/prevent-singleton-pattern-reflection-serialization-cloning/


Adaptor Pattern:
Adapter design pattern is one of the structural design pattern and its used so that two unrelated interfaces can work together. The object that joins these unrelated interface is called an Adapter.

While implementing Adapter pattern, there are two approaches – class adapter and object adapter – however both these approaches produce same result.

Class Adapter – This form uses java inheritance and extends the source interface, in our case Socket class.
Object Adapter – This form uses Java Composition and adapter contains the source object.

Structural design patterns:
Structural design patterns are concerned with how classes and objects can be composed, to form larger structures.

The structural design patterns simplifies the structure by identifying the relationships.

Behavioral Pattern:
Behavioral design patterns are concerned with the interaction and responsibility of objects.

In these design patterns,the interaction between the objects should be in such a way that they can easily talk to each other and still should be loosely coupled.

Strategy Pattern:
In Strategy pattern, a class behavior or its algorithm can be changed at run time. This type of design pattern comes under behavior pattern.
Strategy pattern (also known as the policy pattern) is a software design pattern that enables an algorithm’s behavior to be selected at runtime. The strategy pattern

Facade Design Pattern:
It hides the complexities of the system and provides an interface to the client from where the client can access the system.

Proxy Design Pattern:
Proxy means ‘in place of’, representing’ or ‘in place of’ or ‘on behalf of’ are literal meanings of proxy and that directly explains Proxy Design Pattern. It provides an object that acts as a substitute for a real service object used by a client
Remote proxy, Virtual proxy, Protection proxy


Chain of Responsibility is a behavioral design pattern that lets you pass requests along a chain of handlers. Upon receiving a request, each handler decides either to process the request or to pass it to the next handler in the chain.